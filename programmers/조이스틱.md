## 조이스틱

##### 문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

```
▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동
```

예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.

```
- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
```

만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

#### 제한 사항

- name은 알파벳 대문자로만 이루어져 있습니다.
- name의 길이는 1 이상 20 이하입니다.

#### 입출력 예

| name   | return |
| ------ | ------ |
| JEROEN | 56     |
| JAN    | 23     |



#### 풀이

그리디 알고리즘으로 분류된 문제를 거의 안 풀어봤기 때문에 도전해봤습니다. 조금 후회했네요. 꼬박 반나절이 걸렸고 사실 꽤 고통스러운 시간이었습니다. 어떻게 풀어야할지 감이 잘 오지 않아서 구글링을 해봤는데 조건문 처리가 많은 코드가 대부분이었어요. 왠지 수학적으로 풀 수 있을 것 같아 찾아보다가 괜찮게 보이는 코드를 발견했지만 이해하기가 어려웠습니다. 커서 좌우 이동을 최소화하는 규칙을 패턴화하는 게 쉽지 않았습니다.

집중력이 떨어지면 운동이나 먼저 하고 다시 들여다보면 좋았겠지만 의자에서 엉덩이를 뗄 수 없었습니다. 원문의 설명이 다소 부실해 비어 있는 개념 구멍들을 꼭 메워야겠다고 생각했죠. 새벽이라 사설이 조금 길었습니다.

위아래 조작에 관한 부분은 쉽습니다. `ABC` 방향과 `ZYX`방향 중 적은 값을 더해주면 되거든요. 문제는 **좌우 이동**입니다. `ABAAABBA`를 예로 들겠습니다. 좌우 이동이 가장 적은 경우는 다섯 번인데요, 두 번째 알파벳인 **B**까지 갔다가 역순으로 **A가 아닌 마지막 알파벳_(5번째 B)_**까지 가는 것입니다. 이 부분은 논리적으로 설명하기보다는 몇 가지 테스트 케이스를 통해 규칙을 찾는 게 더 맞는 것 같습니다. 직접 해보셔야 합니다.

뒤에 있는 `BBA`를 먼저 가지 않고 앞에 있는 `AB`를 먼저 갔다가 역순으로 `BBA`으로 접근하는 부분을 공식으로 만들 수 있습니다. 두 번째 알파벳 **B**에서 다섯 번째 알파벳 **B**에 역순으로 네 번만에 도달하는데요. 여기에 두 번째 알파벳 **B**의 인덱스인 1과 다섯 번째 알파벳 **B**의 역순 인덱스인 3_(8 - 5)_중 작은 값인 1을 더한 것입니다. `AB`를 먼저 순회해야 빠르니까요. 현재 진행 중인 인덱스에서 목표 인덱스까지 역순으로 도달하는 갯수가 코드에서 보이는 `length + i  - nextIndex`입니다.

텍스트로만 설명하기 쉽지 않네요. 스스로 고안한 것이 아니기 때문에 아직 완전한 내 것 같지가 않습니다. 이해하고 나서는 머릿속에서만 끄집어내 코드를 작성해 한 번에 맞췄으므로 기본적인 개념이 잡힌 듯하지만 일주일 뒤에 다시 풀면 왠지 또 어려울 것 같습니다.

```java
public class Joystick {	
	public int solution(String name) {
		int answer = 0;    
		int length = name.length();
		int cursorCount = length - 1; // 적당한 초기값
		for (int i = 0; i < name.length(); ++i) {
			int fromA = name.charAt(i) - 'A'; // ABC 방향
			int fromZ = 'Z' - name.charAt(i) + 1; // ZYX 방향
			if (fromA < fromZ) {
				answer += fromA;
			} else {
				answer+= fromZ;
			}
            
             // 다음 위치를 검사해 A가 아닌 알파벳의 위치를 찾는다
			int nextIndex = i + 1;
			while(nextIndex < length && name.charAt(nextIndex) == 'A') {
				++nextIndex;
			}
             // length + i - nextIndex -> i에서 역순으로 nextIndex에 가는 횟수
             // Math.min(i, length - nextIndex) -> 작은 쪽으로 순회를 시작해야 한다
			cursorCount = Math.min(cursorCount, 
					length + i - nextIndex + Math.min(i, length - nextIndex));
		}
	    return answer + cursorCount;
    }
}
```

